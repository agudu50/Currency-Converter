// List of currencies
export const currencies = [
  // Major Global Currencies
  { code: 'USD', name: 'US Dollar', symbol: '$', flag: 'ğŸ‡ºğŸ‡¸' },
  { code: 'EUR', name: 'Euro', symbol: 'â‚¬', flag: 'ğŸ‡ªğŸ‡º' },
  { code: 'GBP', name: 'British Pound', symbol: 'Â£', flag: 'ğŸ‡¬ğŸ‡§' },
  { code: 'JPY', name: 'Japanese Yen', symbol: 'Â¥', flag: 'ğŸ‡¯ğŸ‡µ' },
  { code: 'CHF', name: 'Swiss Franc', symbol: 'CHF', flag: 'ğŸ‡¨ğŸ‡­' },
  { code: 'CAD', name: 'Canadian Dollar', symbol: 'C$', flag: 'ğŸ‡¨ğŸ‡¦' },
  { code: 'AUD', name: 'Australian Dollar', symbol: 'A$', flag: 'ğŸ‡¦ğŸ‡º' },
  { code: 'CNY', name: 'Chinese Yuan', symbol: 'Â¥', flag: 'ğŸ‡¨ğŸ‡³' },

  // Asia Pacific
  { code: 'INR', name: 'Indian Rupee', symbol: 'â‚¹', flag: 'ğŸ‡®ğŸ‡³' },
  { code: 'KRW', name: 'South Korean Won', symbol: 'â‚©', flag: 'ğŸ‡°ğŸ‡·' },
  { code: 'SGD', name: 'Singapore Dollar', symbol: 'S$', flag: 'ğŸ‡¸ğŸ‡¬' },
  { code: 'HKD', name: 'Hong Kong Dollar', symbol: 'HK$', flag: 'ğŸ‡­ğŸ‡°' },
  { code: 'TWD', name: 'Taiwan Dollar', symbol: 'NT$', flag: 'ğŸ‡¹ğŸ‡¼' },
  { code: 'PHP', name: 'Philippine Peso', symbol: 'â‚±', flag: 'ğŸ‡µğŸ‡­' },
  { code: 'MYR', name: 'Malaysian Ringgit', symbol: 'RM', flag: 'ğŸ‡²ğŸ‡¾' },
  { code: 'THB', name: 'Thai Baht', symbol: 'à¸¿', flag: 'ğŸ‡¹ğŸ‡­' },
  { code: 'IDR', name: 'Indonesian Rupiah', symbol: 'Rp', flag: 'ğŸ‡®ğŸ‡©' },
  { code: 'VND', name: 'Vietnamese Dong', symbol: 'â‚«', flag: 'ğŸ‡»ğŸ‡³' },
  { code: 'PKR', name: 'Pakistani Rupee', symbol: 'â‚¨', flag: 'ğŸ‡µğŸ‡°' },
  { code: 'BDT', name: 'Bangladeshi Taka', symbol: 'à§³', flag: 'ğŸ‡§ğŸ‡©' },
  { code: 'LKR', name: 'Sri Lankan Rupee', symbol: 'Rs', flag: 'ğŸ‡±ğŸ‡°' },
  { code: 'NPR', name: 'Nepalese Rupee', symbol: 'â‚¨', flag: 'ğŸ‡³ğŸ‡µ' },
  { code: 'MMK', name: 'Myanmar Kyat', symbol: 'K', flag: 'ğŸ‡²ğŸ‡²' },
  { code: 'KHR', name: 'Cambodian Riel', symbol: 'áŸ›', flag: 'ğŸ‡°ğŸ‡­' },
  { code: 'LAK', name: 'Lao Kip', symbol: 'â‚­', flag: 'ğŸ‡±ğŸ‡¦' },
  { code: 'BND', name: 'Brunei Dollar', symbol: 'B$', flag: 'ğŸ‡§ğŸ‡³' },
  { code: 'NZD', name: 'New Zealand Dollar', symbol: 'NZ$', flag: 'ğŸ‡³ğŸ‡¿' },
  { code: 'FJD', name: 'Fijian Dollar', symbol: 'FJ$', flag: 'ğŸ‡«ğŸ‡¯' },

  // Middle East
  { code: 'AED', name: 'UAE Dirham', symbol: 'Ø¯.Ø¥', flag: 'ğŸ‡¦ğŸ‡ª' },
  { code: 'SAR', name: 'Saudi Riyal', symbol: 'ï·¼', flag: 'ğŸ‡¸ğŸ‡¦' },
  { code: 'QAR', name: 'Qatari Riyal', symbol: 'Ø±.Ù‚', flag: 'ğŸ‡¶ğŸ‡¦' },
  { code: 'KWD', name: 'Kuwaiti Dinar', symbol: 'Ø¯.Ùƒ', flag: 'ğŸ‡°ğŸ‡¼' },
  { code: 'BHD', name: 'Bahraini Dinar', symbol: '.Ø¯.Ø¨', flag: 'ğŸ‡§ğŸ‡­' },
  { code: 'OMR', name: 'Omani Rial', symbol: 'Ø±.Ø¹.', flag: 'ğŸ‡´ğŸ‡²' },
  { code: 'JOD', name: 'Jordanian Dinar', symbol: 'Ø¯.Ø§', flag: 'ğŸ‡¯ğŸ‡´' },
  { code: 'LBP', name: 'Lebanese Pound', symbol: 'Ù„.Ù„', flag: 'ğŸ‡±ğŸ‡§' },
  { code: 'ILS', name: 'Israeli Shekel', symbol: 'â‚ª', flag: 'ğŸ‡®ğŸ‡±' },
  { code: 'TRY', name: 'Turkish Lira', symbol: 'â‚º', flag: 'ğŸ‡¹ğŸ‡·' },
  { code: 'IRR', name: 'Iranian Rial', symbol: 'ï·¼', flag: 'ğŸ‡®ğŸ‡·' },

  // Europe
  { code: 'NOK', name: 'Norwegian Krone', symbol: 'kr', flag: 'ğŸ‡³ğŸ‡´' },
  { code: 'SEK', name: 'Swedish Krona', symbol: 'kr', flag: 'ğŸ‡¸ğŸ‡ª' },
  { code: 'DKK', name: 'Danish Krone', symbol: 'kr', flag: 'ğŸ‡©ğŸ‡°' },
  { code: 'ISK', name: 'Icelandic Krona', symbol: 'kr', flag: 'ğŸ‡®ğŸ‡¸' },
  { code: 'PLN', name: 'Polish Zloty', symbol: 'zÅ‚', flag: 'ğŸ‡µğŸ‡±' },
  { code: 'CZK', name: 'Czech Koruna', symbol: 'KÄ', flag: 'ğŸ‡¨ğŸ‡¿' },
  { code: 'HUF', name: 'Hungarian Forint', symbol: 'Ft', flag: 'ğŸ‡­ğŸ‡º' },
  { code: 'RON', name: 'Romanian Leu', symbol: 'lei', flag: 'ğŸ‡·ğŸ‡´' },
  { code: 'BGN', name: 'Bulgarian Lev', symbol: 'Ğ»Ğ²', flag: 'ğŸ‡§ğŸ‡¬' },
  { code: 'HRK', name: 'Croatian Kuna', symbol: 'kn', flag: 'ğŸ‡­ğŸ‡·' },
  { code: 'RSD', name: 'Serbian Dinar', symbol: 'Ğ´Ğ¸Ğ½', flag: 'ğŸ‡·ğŸ‡¸' },
  { code: 'BAM', name: 'Bosnia-Herzegovina Convertible Mark', symbol: 'KM', flag: 'ğŸ‡§ğŸ‡¦' },
  { code: 'MKD', name: 'Macedonian Denar', symbol: 'Ğ´ĞµĞ½', flag: 'ğŸ‡²ğŸ‡°' },
  { code: 'ALL', name: 'Albanian Lek', symbol: 'L', flag: 'ğŸ‡¦ğŸ‡±' },
  { code: 'RUB', name: 'Russian Ruble', symbol: 'â‚½', flag: 'ğŸ‡·ğŸ‡º' },
  { code: 'UAH', name: 'Ukrainian Hryvnia', symbol: 'â‚´', flag: 'ğŸ‡ºğŸ‡¦' },
  { code: 'BYN', name: 'Belarusian Ruble', symbol: 'Br', flag: 'ğŸ‡§ğŸ‡¾' },
  { code: 'MDL', name: 'Moldovan Leu', symbol: 'L', flag: 'ğŸ‡²ğŸ‡©' },

  // Americas
  { code: 'BRL', name: 'Brazilian Real', symbol: 'R$', flag: 'ğŸ‡§ğŸ‡·' },
  { code: 'MXN', name: 'Mexican Peso', symbol: '$', flag: 'ğŸ‡²ğŸ‡½' },
  { code: 'ARS', name: 'Argentine Peso', symbol: '$', flag: 'ğŸ‡¦ğŸ‡·' },
  { code: 'CLP', name: 'Chilean Peso', symbol: '$', flag: 'ğŸ‡¨ğŸ‡±' },
  { code: 'COP', name: 'Colombian Peso', symbol: '$', flag: 'ğŸ‡¨ğŸ‡´' },
  { code: 'PEN', name: 'Peruvian Sol', symbol: 'S/', flag: 'ğŸ‡µğŸ‡ª' },
  { code: 'UYU', name: 'Uruguayan Peso', symbol: '$U', flag: 'ğŸ‡ºğŸ‡¾' },
  { code: 'PYG', name: 'Paraguayan Guarani', symbol: 'â‚²', flag: 'ğŸ‡µğŸ‡¾' },
  { code: 'BOB', name: 'Bolivian Boliviano', symbol: 'Bs', flag: 'ğŸ‡§ğŸ‡´' },
  { code: 'VES', name: 'Venezuelan BolÃ­var', symbol: 'Bs.S', flag: 'ğŸ‡»ğŸ‡ª' },
  { code: 'GYD', name: 'Guyanese Dollar', symbol: 'G$', flag: 'ğŸ‡¬ğŸ‡¾' },
  { code: 'SRD', name: 'Surinamese Dollar', symbol: '$', flag: 'ğŸ‡¸ğŸ‡·' },
  { code: 'CRC', name: 'Costa Rican ColÃ³n', symbol: 'â‚¡', flag: 'ğŸ‡¨ğŸ‡·' },
  { code: 'GTQ', name: 'Guatemalan Quetzal', symbol: 'Q', flag: 'ğŸ‡¬ğŸ‡¹' },
  { code: 'HNL', name: 'Honduran Lempira', symbol: 'L', flag: 'ğŸ‡­ğŸ‡³' },
  { code: 'NIO', name: 'Nicaraguan CÃ³rdoba', symbol: 'C$', flag: 'ğŸ‡³ğŸ‡®' },
  { code: 'PAB', name: 'Panamanian Balboa', symbol: 'B/.', flag: 'ğŸ‡µğŸ‡¦' },
  { code: 'DOP', name: 'Dominican Peso', symbol: 'RD$', flag: 'ğŸ‡©ğŸ‡´' },
  { code: 'CUP', name: 'Cuban Peso', symbol: '$', flag: 'ğŸ‡¨ğŸ‡º' },
  { code: 'JMD', name: 'Jamaican Dollar', symbol: 'J$', flag: 'ğŸ‡¯ğŸ‡²' },
  { code: 'HTG', name: 'Haitian Gourde', symbol: 'G', flag: 'ğŸ‡­ğŸ‡¹' },
  { code: 'TTD', name: 'Trinidad and Tobago Dollar', symbol: 'TT$', flag: 'ğŸ‡¹ğŸ‡¹' },
  { code: 'BBD', name: 'Barbadian Dollar', symbol: 'Bds$', flag: 'ğŸ‡§ğŸ‡§' },

  // Africa
  { code: 'ZAR', name: 'South African Rand', symbol: 'R', flag: 'ğŸ‡¿ğŸ‡¦' },
  { code: 'NGN', name: 'Nigerian Naira', symbol: 'â‚¦', flag: 'ğŸ‡³ğŸ‡¬' },
  { code: 'EGP', name: 'Egyptian Pound', symbol: 'Ø¬.Ù…', flag: 'ğŸ‡ªğŸ‡¬' },
  { code: 'KES', name: 'Kenyan Shilling', symbol: 'KSh', flag: 'ğŸ‡°ğŸ‡ª' },
  { code: 'GHS', name: 'Ghanaian Cedi', symbol: 'â‚µ', flag: 'ğŸ‡¬ğŸ‡­' },
  { code: 'TZS', name: 'Tanzanian Shilling', symbol: 'TSh', flag: 'ğŸ‡¹ğŸ‡¿' },
  { code: 'UGX', name: 'Ugandan Shilling', symbol: 'USh', flag: 'ğŸ‡ºğŸ‡¬' },
  { code: 'RWF', name: 'Rwandan Franc', symbol: 'FRw', flag: 'ğŸ‡·ğŸ‡¼' },
  { code: 'ETB', name: 'Ethiopian Birr', symbol: 'Br', flag: 'ğŸ‡ªğŸ‡¹' },
  { code: 'MAD', name: 'Moroccan Dirham', symbol: 'Ø¯.Ù….', flag: 'ğŸ‡²ğŸ‡¦' },
  { code: 'TND', name: 'Tunisian Dinar', symbol: 'Ø¯.Øª', flag: 'ğŸ‡¹ğŸ‡³' },
  { code: 'DZD', name: 'Algerian Dinar', symbol: 'Ø¯.Ø¬', flag: 'ğŸ‡©ğŸ‡¿' },
  { code: 'LYD', name: 'Libyan Dinar', symbol: 'Ù„.Ø¯', flag: 'ğŸ‡±ğŸ‡¾' },
  { code: 'SDG', name: 'Sudanese Pound', symbol: 'Ø¬.Ø³.', flag: 'ğŸ‡¸ğŸ‡©' },
  { code: 'AOA', name: 'Angolan Kwanza', symbol: 'Kz', flag: 'ğŸ‡¦ğŸ‡´' },
  { code: 'ZMW', name: 'Zambian Kwacha', symbol: 'ZK', flag: 'ğŸ‡¿ğŸ‡²' },
  { code: 'BWP', name: 'Botswanan Pula', symbol: 'P', flag: 'ğŸ‡§ğŸ‡¼' },
  { code: 'NAD', name: 'Namibian Dollar', symbol: 'N$', flag: 'ğŸ‡³ğŸ‡¦' },
  { code: 'SZL', name: 'Swazi Lilangeni', symbol: 'L', flag: 'ğŸ‡¸ğŸ‡¿' },
  { code: 'LSL', name: 'Lesotho Loti', symbol: 'L', flag: 'ğŸ‡±ğŸ‡¸' },
  { code: 'MWK', name: 'Malawian Kwacha', symbol: 'MK', flag: 'ğŸ‡²ğŸ‡¼' },
  { code: 'MZN', name: 'Mozambican Metical', symbol: 'MT', flag: 'ğŸ‡²ğŸ‡¿' },
  { code: 'MGA', name: 'Malagasy Ariary', symbol: 'Ar', flag: 'ğŸ‡²ğŸ‡¬' },
  { code: 'MUR', name: 'Mauritian Rupee', symbol: 'â‚¨', flag: 'ğŸ‡²ğŸ‡º' },
  { code: 'SCR', name: 'Seychellois Rupee', symbol: 'â‚¨', flag: 'ğŸ‡¸ğŸ‡¨' },

  // Oceania & Others
  { code: 'PGK', name: 'Papua New Guinea Kina', symbol: 'K', flag: 'ğŸ‡µğŸ‡¬' },
  { code: 'SBD', name: 'Solomon Islands Dollar', symbol: 'SI$', flag: 'ğŸ‡¸ğŸ‡§' },
  { code: 'VUV', name: 'Vanuatu Vatu', symbol: 'VT', flag: 'ğŸ‡»ğŸ‡º' },
  { code: 'TOP', name: 'Tongan PaÊ»anga', symbol: 'T$', flag: 'ğŸ‡¹ğŸ‡´' },
  { code: 'WST', name: 'Samoan Tala', symbol: 'WS$', flag: 'ğŸ‡¼ğŸ‡¸' },

  // Additional Major Economies
  { code: 'XOF', name: 'West African CFA Franc', symbol: 'CFA', flag: 'ğŸ›ï¸' },
  { code: 'XAF', name: 'Central African CFA Franc', symbol: 'FCFA', flag: 'ğŸ›ï¸' },
  { code: 'XCD', name: 'East Caribbean Dollar', symbol: 'EC$', flag: 'ğŸï¸' },
  { code: 'AFN', name: 'Afghan Afghani', symbol: 'Ø‹', flag: 'ğŸ‡¦ğŸ‡«' },
  { code: 'AMD', name: 'Armenian Dram', symbol: 'Ö', flag: 'ğŸ‡¦ğŸ‡²' },
  { code: 'AZN', name: 'Azerbaijani Manat', symbol: 'â‚¼', flag: 'ğŸ‡¦ğŸ‡¿' },
  { code: 'GEL', name: 'Georgian Lari', symbol: 'â‚¾', flag: 'ğŸ‡¬ğŸ‡ª' },
  { code: 'KZT', name: 'Kazakhstani Tenge', symbol: 'â‚¸', flag: 'ğŸ‡°ğŸ‡¿' },
  { code: 'KGS', name: 'Kyrgyzstani Som', symbol: 'Ñ', flag: 'ğŸ‡°ğŸ‡¬' },
  { code: 'TJS', name: 'Tajikistani Somoni', symbol: 'SM', flag: 'ğŸ‡¹ğŸ‡¯' },
  { code: 'TMT', name: 'Turkmenistani Manat', symbol: 'T', flag: 'ğŸ‡¹ğŸ‡²' },
  { code: 'UZS', name: 'Uzbekistani Som', symbol: "soÊ»m", flag: 'ğŸ‡ºğŸ‡¿' },
  { code: 'MNT', name: 'Mongolian Tugrik', symbol: 'â‚®', flag: 'ğŸ‡²ğŸ‡³' },
];

// API Configuration (CurrencyAPI)
const API_KEY = import.meta.env.VITE_CURRENCY_API_KEY || 'cur_live_Yd5afKlYfaoJznq6fF31WfLBOrslsVDHYSEPnFyE';
const BASE_URL = 'https://api.currencyapi.com/v3/latest';
const HISTORICAL_URL = 'https://api.currencyapi.com/v3/historical';

// Cache for exchange rates
let ratesCache = {
  rates: null,
  timestamp: null,
  baseCurrency: 'USD'
};

// Track in-flight requests to avoid duplicate API calls
let inflightRequests = new Map();

const CACHE_DURATION = 60 * 60 * 1000; // 1 hour in milliseconds

// Fetch exchange rates from API
// options.requireLive: if true, do NOT fall back to mock data; throw on failure
export async function fetchExchangeRates(baseCurrency = 'USD', options = {}) {
  const { requireLive = false } = options;
  const now = Date.now();
  
  // Return cached data if still valid and same base currency
  if (
    ratesCache.rates &&
    ratesCache.timestamp &&
    ratesCache.baseCurrency === baseCurrency &&
    now - ratesCache.timestamp < CACHE_DURATION
  ) {
    return ratesCache.rates;
  }

  // If a request for this base currency is already in flight, wait for it
  if (inflightRequests.has(baseCurrency)) {
    return inflightRequests.get(baseCurrency);
  }

  // Create a new request promise and track it
  const requestPromise = (async () => {
    try {
      const url = `${BASE_URL}?apikey=${API_KEY}&base_currency=${baseCurrency}`;
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`API Error: ${response.status}`);
      }

      const data = await response.json();

      if (data?.data) {
        // currencyapi.com returns { data: { USD: { code, value }, ... } }
        const parsedRates = Object.fromEntries(
          Object.entries(data.data).map(([code, entry]) => [code, entry?.value ?? 0])
        );

        ratesCache = {
          rates: parsedRates,
          timestamp: now,
          baseCurrency: baseCurrency
        };
        return parsedRates;
      }

      throw new Error('API request failed: missing data');
    } catch (error) {
      console.error('Error fetching exchange rates:', error);
      if (requireLive) {
        throw error;
      }
      // Return mock rates as fallback when live is not required
      return getMockExchangeRates();
    } finally {
      // Remove this request from in-flight tracking
      inflightRequests.delete(baseCurrency);
    }
  })();

  // Track this request
  inflightRequests.set(baseCurrency, requestPromise);
  return requestPromise;
}

// Mock exchange rates (fallback)
function getMockExchangeRates() {
  return {
    'USD': 1.0000,
    'EUR': 0.8500,
    'GBP': 0.7300,
    'JPY': 110.2500,
    'CHF': 0.9200,
    'CAD': 1.2500,
    'AUD': 1.3500,
    'CNY': 6.4500,
    'INR': 74.5000,
    'KRW': 1180.0000,
    'SGD': 1.3500,
    'HKD': 7.7500,
    'TWD': 28.0000,
    'PHP': 50.5000,
    'MYR': 4.1500,
    'THB': 33.2500,
    'IDR': 14250.0000,
    'VND': 23000.0000,
    'PKR': 175.0000,
    'BDT': 85.0000,
    'BRL': 5.2500,
    'MXN': 20.0000,
    'ARS': 98.5000,
    'ZAR': 15.0000,
    'NGN': 410.0000,
    'EGP': 15.7500,
    'RUB': 73.5000,
    'TRY': 8.5000,
    'AED': 3.6700,
    'SAR': 3.7500,
  };
}

// Convert currency (synchronous - for backward compatibility)
export function convertCurrency(amount, fromCurrency, toCurrency) {
  // This uses cached rates if available, otherwise returns mock calculation
  const rates = ratesCache.rates || getMockExchangeRates();
  const fromRate = rates[fromCurrency] || 1;
  const toRate = rates[toCurrency] || 1;
  const usdAmount = amount / fromRate;
  return usdAmount * toRate;
}

// Convert currency (async - recommended)
// options.requireLive: if true, forces live rates (throws on failure instead of mock)
export async function convertCurrencyAsync(amount, fromCurrency, toCurrency, options = {}) {
  const { requireLive = false } = options;
  const rates = await fetchExchangeRates('USD', { requireLive });
  const fromRate = rates[fromCurrency] || 1;
  const toRate = rates[toCurrency] || 1;
  const usdAmount = amount / fromRate;
  return usdAmount * toRate;
}

// Available currency codes from the latest fetched rates
export function getAvailableCurrencyCodes() {
  // If we have fetched rates, use those
  if (ratesCache.rates && Object.keys(ratesCache.rates).length > 0) {
    const codes = Object.keys(ratesCache.rates);
    
    if (!codes.includes('USD')) codes.push('USD');
    return codes;
  }
  // Otherwise, return all supported currency codes from our currencies array
  return currencies.map(c => c.code);
}

// Format currency
export function formatCurrency(amount, currencyCode) {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currencyCode,
    minimumFractionDigits: 2,
    maximumFractionDigits: 4,
  }).format(amount);
}

// Generate mock historical data (fallback)
export function generateHistoricalData(fromCurrency, toCurrency, days = 30) {
  const data = [];
  const baseRate = convertCurrency(1, fromCurrency, toCurrency);

  for (let i = days; i >= 0; i--) {
    const date = new Date();
    date.setDate(date.getDate() - i);

    const variance = (Math.random() - 0.5) * 0.1; // Â±5%
    const rate = baseRate * (1 + variance);

    data.push({
      date: date.toISOString().split('T')[0],
      rate: Number(rate.toFixed(4)),
      dateFormatted: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
    });
  }

  return data;
}

// Fetch historical rates (live) with fallback to mock
export async function fetchHistoricalRates(fromCurrency, toCurrency, days = 30) {
  // Primary: exchangerate.host timeseries (single request)
  const end = new Date();
  const start = new Date();
  start.setDate(end.getDate() - days);
  const formatDate = (d) => d.toISOString().split('T')[0];
  const url = `https://api.exchangerate.host/timeseries?start_date=${formatDate(start)}&end_date=${formatDate(end)}&base=${fromCurrency}&symbols=${toCurrency}`;

  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Historical API error ${res.status}`);
    const data = await res.json();
    if (!data.rates) throw new Error('Historical API missing rates');

    const entries = Object.entries(data.rates)
      .sort(([a], [b]) => new Date(a) - new Date(b))
      .map(([date, value]) => ({
        date,
        rate: Number((value?.[toCurrency] ?? 0).toFixed(4)),
        dateFormatted: new Date(date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
      }))
      .filter((d) => d.rate > 0);

    if (!entries.length) throw new Error('Historical API returned empty data');
    return entries;
  } catch (err) {
    console.warn('Historical fetch fallback to mock data:', err?.message || err);
    return generateHistoricalData(fromCurrency, toCurrency, days);
  }
}

// Batch historical fetch for multiple symbols (reduces API calls)
export async function fetchHistoricalRatesBatch(baseCurrency, symbols = [], days = 7) {
  const end = new Date();
  const start = new Date();
  start.setDate(end.getDate() - days);
  const formatDate = (d) => d.toISOString().split('T')[0];
  const qs = encodeURIComponent(symbols.join(','));
  const url = `https://api.exchangerate.host/timeseries?start_date=${formatDate(start)}&end_date=${formatDate(end)}&base=${baseCurrency}&symbols=${qs}`;
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Historical API error ${res.status}`);
    const data = await res.json();
    if (!data.rates) throw new Error('Historical API missing rates');

    // Build map: symbol -> array of entries
    const map = new Map();
    symbols.forEach((s) => map.set(s, []));
    Object.entries(data.rates)
      .sort(([a], [b]) => new Date(a) - new Date(b))
      .forEach(([date, obj]) => {
        symbols.forEach((s) => {
          const val = obj?.[s];
          const rate = Number((val ?? 0).toFixed(4));
          map.get(s).push({
            date,
            rate,
            dateFormatted: new Date(date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
          });
        });
      });

    return map;
  } catch (err) {
    console.warn('Batch historical fetch fallback to mock data:', err?.message || err);
    // Fallback: build mock series per symbol
    const map = new Map();
    symbols.forEach((s) => {
      map.set(s, generateHistoricalData(baseCurrency, s, days));
    });
    return map;
  }
}
